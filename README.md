# The-16-Bit-PC-Software(ongoing)

![Alt text](Roadmap.png?raw=true "Title") 

Now that we have a basic functioning computer as our foundation(we built in [The 16 bit PC](https://www.notion.so/From-NAND-to-Tetris-1-561e43324a0145eaaa1a2d5aefbdcf74) or the one we're using), it only makes sense to utilize it to its full potential. Although we have an assembly language and an assembler to convert our programs to machine code and interact with the computer, the amount of sophistication we can achieve writing in simple assembly is quite minimum, especially considering the redundancy while programming and the principles it operates on. Here, by no stretch am I stating that assembly language is trivial, in fact its the key to our interaction with the computer, but instead isn't well suited to interact with the us humans for writing even slightly complex programs/tasks without breaking a sweat. 

But of course we do have an entire elaborate system of languages that are much more user friendly, use significant concepts such as abstraction and modularity, and have an intricate amount of depth built right into their layers to make writing complex programs a breeze(relatively). High Level, Object oriented programming languages offer so much to the table of a software designer and are built upon layers and layers of abstraction which if unpacked ultimately meet our good old assembly language.

We begin by designing a Virtual Machine Language Translator that translates VM files to native assembly. This brings about the notion of memory segments, the stack and functions along with everything we've accumulated over in assembly.


 ## Others: 
 
 Notes and details at (Ongoing) [https://scientia72.notion.site/From-Nand-To-Tetris-2-309beb5ead794857a576353da5dba454] 
